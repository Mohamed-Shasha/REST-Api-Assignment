export declare function writeInt32BE(bytes: Uint8Array, offset: number, value: number): number;
export declare function writeInt32LE(bytes: Uint8Array, offset: number, value: number): number;
export declare function fromUint8Array(bytes: Uint8Array): string;
export declare function toBinaryString(bytes: Uint8Array | ArrayBufferLike): string;
export declare class ByteStream {
    protected buffer: Uint8Array;
    protected size: number;
    protected offset: number;
    protected rmark: number;
    protected wmark: number;
    /**
     * Decodes data to a string according to the Type.
     * @param data to be decoded to a string.
     */
    static toString(data?: string | Uint8Array | ByteStream | ArrayBuffer | ArrayLike<number>): string;
    /**
     * Constructs a ByteStream object with no bytes in it and the specified initial capacity.
     * @param capacity the initial capacity.
     */
    constructor(capacity: number);
    /**
     * Constructs a ByteStream object initialized to the contents of the data.
     * @param data the initial contents of this stream.
     */
    constructor(data?: string | Uint8Array | Uint8ClampedArray | ByteStream | ArrayLike<number> | ArrayBufferLike);
    protected grow(n: number): void;
    /**
     * Returns the current capacity of this stream.
     */
    get capacity(): number;
    /**
     * Returns the current length of the data in this stream.
     */
    get length(): number;
    /**
     * Returns the position of the next reading operation in this stream.
     */
    get position(): number;
    /**
     * Returns all bytes data in this stream.
     * If the returned data is changed, the data in this stream will be also changed.
     */
    get bytes(): Uint8Array;
    /**
     * Returns all bytes data in this stream that has not been read.
     * If the returned data is changed, the data in this stream will be also changed.
     */
    get remains(): Uint8Array;
    /**
     * Sets this stream's mark at its reading and writing position.
     */
    mark(): void;
    /**
     * Resets this stream's reading and writing position to the previously-marked position.
     * Invoking this method neither changes nor discards the mark's value.
     */
    reset(): void;
    /**
     * Clears this stream.
     * The position is set to zero, the limit is set to the capacity, and the mark is discarded.
     */
    clear(): void;
    /**
     * Writes a byte to the stream as a 1-byte value.
     * @param byte a byte value to be written.
     */
    writeByte(byte: number): void;
    /**
     * Writes value to this stream with big endian format.
     * @param value number to be written to this stream. value should be a valid signed 32-bit integer.
     * TypeError will be throwed when value is anything other than a signed 32-bit integer.
     */
    writeInt32BE(value: number): void;
    /**
     * Writes value to this stream with big endian format.
     * @param value number to be written to this stream. value should be a valid unsigned 32-bit integer.
     * TypeError will be throwed when value is anything other than an unsigned 32-bit integer.
     */
    writeUInt32BE(value: number): void;
    /**
     * Writes value to this stream with little endian format.
     * @param value number to be written to this stream. value should be a valid signed 32-bit integer.
     * TypeError will be throwed when value is anything other than a signed 32-bit integer.
     */
    writeInt32LE(value: number): void;
    /**
     * Writes value to this stream with little endian format.
     * @param value number to be written to this stream. value should be a valid unsigned 32-bit integer.
     * TypeError will be throwed when value is anything other than an unsigned 32-bit integer.
     */
    writeUInt32LE(value: number): void;
    /**
     * Writes binary data to this stream.
     * @param data to be written to this stream.
     */
    write(data: Uint8Array | Uint8ClampedArray | ByteStream | ArrayLike<number> | ArrayBuffer): void;
    /**
     * Writes str to this stream with ascii encoding.
     * @param str to be written to this stream.
     */
    writeAsciiString(str: string): void;
    /**
     * Writes str to this stream with utf8 encoding.
     * @param str to be written to this stream.
     */
    writeString(str: string): void;
    /**
     * Reads and returns a single byte.
     * If no byte is available, returns -1.
     */
    readByte(): number;
    /**
     * Reads a signed 32-bit integer from this stream with the big endian format.
     * If the remaining data is less than 4 bytes, Error('EOF') will be throw.
     */
    readInt32BE(): number;
    /**
     * Reads an unsigned 32-bit integer from this stream with the big endian format.
     * If the remaining data is less than 4 bytes, Error('EOF') will be throw.
     */
    readUInt32BE(): number;
    /**
     * Reads a signed 32-bit integer from this stream with the little endian format.
     * If the remaining data is less than 4 bytes, Error('EOF') will be throw.
     */
    readInt32LE(): number;
    /**
     * Reads an unsigned 32-bit integer from this stream with the little endian format.
     * If the remaining data is less than 4 bytes, Error('EOF') will be throw.
     */
    readUInt32LE(): number;
    /**
     * Reads n bytes of data from this stream and returns the result as a Uint8Array.
     * If n is negative, reads to the end of this stream.
     * @param n The maximum number of bytes to read.
     */
    read(n: number): Uint8Array;
    /**
     * Skips over and discards n bytes of data from this stream.
     * The actual number of bytes skipped is returned.
     * If n is negative, all remaining bytes are skipped.
     * @param n the number of bytes to be skipped.
     */
    skip(n: number): number;
    /**
     * Returns a Uint8Array from the current position to the delimiter. The result includes delimiter.
     * Returns all remaining data if no delimiter is found.
     * After this method is called, The new position is after the delimiter.
     * @param delimiter a byte, which represents the end of reading data.
     */
    readBytes(delimiter: number): Uint8Array;
    /**
     * Returns a string from the current position to the delimiter. The result doesn't include delimiter.
     * Returns all remaining data if no delimiter is found.
     * After this method is called, the new position is after the delimiter.
     * @param delimiter a byte, which represents the end of reading data.
     */
    readUntil(delimiter: number): string;
    /**
     * Reads n bytes of data from this stream and returns the result as an ascii string.
     * If n is negative, reads to the end of this stream.
     * @param n The maximum number of bytes to read.
     */
    readAsciiString(n: number): string;
    /**
     * Returns a Uint8Array containing a string of length n.
     * If n is negative, reads to the end of this stream.
     * @param n is the string(UTF16) length.
     */
    readStringAsBytes(n: number): Uint8Array;
    /**
     * Returns a string of length n.
     * If n is negative, reads to the end of this stream.
     * @param n is the string(UTF16) length.
     */
    readString(n: number): string;
    /**
     * Returns a view of the the internal buffer and clears `this`.
     */
    takeBytes(): Uint8Array;
    /**
     * Returns a copy of the current contents and leaves `this` intact.
     */
    toBytes(): Uint8Array;
    /**
     * Returns a string representation of this stream.
     */
    toString(): string;
    /**
     * Creates an exact copy of this stream.
     */
    clone(): ByteStream;
    /**
     * Truncates this stream, only leaves the unread data.
     * The position is reset to 0.
     * The mark is cleared.
     */
    trunc(): void;
}
//# sourceMappingURL=ByteStream.d.ts.map