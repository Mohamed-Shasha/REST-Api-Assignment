"use strict";
/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| MethodManager.ts                                         |
|                                                          |
| MethodManager for TypeScript.                            |
|                                                          |
| LastModified: Mar 28, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var Method_1 = require("./Method");
var MethodManager = /** @class */ (function () {
    function MethodManager() {
        this.methods = Object.create(null);
        this.names = [];
    }
    MethodManager.prototype.getNames = function () {
        return this.names;
    };
    MethodManager.prototype.get = function (name) {
        name = name.toLowerCase();
        return (name in this.methods) ? this.methods[name] : this.methods['*'];
    };
    MethodManager.prototype.remove = function (name) {
        delete this.methods[name.toLowerCase()];
        var index = this.names.indexOf(name);
        if (index > -1) {
            this.names.splice(index, 1);
        }
    };
    MethodManager.prototype.add = function (method) {
        var name = method.name;
        if (name === '' || name === undefined) {
            name = method.fullname;
            if (name === '' || name === undefined) {
                name = method.method.name;
                if (name === '') {
                    throw new Error('name must not be empty');
                }
            }
            method.name = name;
        }
        this.methods[name.toLowerCase()] = method;
        if (this.names.indexOf(name) === -1) {
            this.names.push(name);
        }
    };
    MethodManager.prototype.addFunction = function (fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        switch (args.length) {
            case 0:
                this.add(new Method_1.Method(fn));
                break;
            case 1:
                if (typeof args[0] === 'string') {
                    this.add(new Method_1.Method(fn, args[0]));
                }
                else {
                    this.add(new Method_1.Method(fn, undefined, undefined, args[0]));
                }
                break;
            case 2:
                this.add(new Method_1.Method(fn, args[0], undefined, args[1]));
                break;
        }
    };
    MethodManager.prototype.addMethod = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (typeof args[0] === 'string') {
            var method = args[1][args[0]];
            if (typeof method === 'function') {
                this.add(new Method_1.Method(method, args[0], args[1], args[2]));
            }
            else {
                throw new Error('obj[name] must be a function');
            }
        }
        else {
            switch (args.length) {
                case 2:
                    this.add(new Method_1.Method(args[0], undefined, args[1]));
                    break;
                case 3:
                    if (typeof args[2] === 'string') {
                        this.add(new Method_1.Method(args[0], args[2], args[1]));
                    }
                    else {
                        this.add(new Method_1.Method(args[0], undefined, args[1], args[2]));
                    }
                    break;
                case 4:
                    this.add(new Method_1.Method(args[0], args[2], args[1], args[3]));
            }
        }
    };
    MethodManager.prototype.addMissingMethod = function (fn, target) {
        var method = new Method_1.Method(fn, '*', target);
        method.missing = true;
        if (fn.length === 3) {
            method.passContext = true;
        }
        this.add(method);
    };
    MethodManager.prototype.addFunctions = function (functions) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var names;
        var paramTypes;
        switch (args.length) {
            case 1:
                if ((args[0].length > 1) && (typeof args[0][0] === 'string')) {
                    names = args[0];
                }
                else {
                    paramTypes = args[0];
                }
                break;
            case 2:
                names = args[0];
                paramTypes = args[1];
                break;
        }
        var n = functions.length;
        if (names && names.length !== n) {
            throw new Error('names.length must be equal to functions.length');
        }
        for (var i = 0; i < n; ++i) {
            this.add(new Method_1.Method(functions[i], names ? names[i] : undefined, undefined, paramTypes));
        }
    };
    MethodManager.prototype.addMethods = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var n = args[0].length;
        if (n === 0)
            return;
        var methods;
        var target = args[1];
        var names;
        var paramTypes;
        if (typeof args[0][0] === 'string') {
            names = args[0];
            paramTypes = args[2];
            for (var i = 0; i < n; ++i) {
                var method = target[names[i]];
                if (typeof method === 'function') {
                    this.add(new Method_1.Method(method, names[i], target, paramTypes));
                }
                else {
                    throw new Error('obj[name] must be a function');
                }
            }
            return;
        }
        else {
            methods = args[0];
        }
        switch (args.length) {
            case 3:
                if (args[2].length > 0 && typeof args[2][0] === 'string') {
                    names = args[2];
                }
                else {
                    paramTypes = args[2];
                }
                break;
            case 4:
                names = args[2];
                paramTypes = args[3];
        }
        if (names && names.length !== n) {
            throw new Error('names.length must be equal to functions.length');
        }
        for (var i = 0; i < n; ++i) {
            this.add(new Method_1.Method(methods[i], names ? names[i] : undefined, target, paramTypes));
        }
    };
    MethodManager.prototype.addInstanceMethods = function (target, namespace) {
        for (var name_1 in target) {
            if ((!target.hasOwnProperty || target.hasOwnProperty(name_1)) && typeof target[name_1] === 'function') {
                var fullname = namespace ? namespace + '_' + name_1 : name_1;
                this.add(new Method_1.Method(target[name_1], fullname, target));
            }
        }
    };
    return MethodManager;
}());
exports.MethodManager = MethodManager;
//# sourceMappingURL=MethodManager.js.map