"use strict";
/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ServiceCodec.ts                                          |
|                                                          |
| ServiceCodec for TypeScript.                             |
|                                                          |
| LastModified: Mar 28, 2020                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var io_1 = require("@hprose/io");
var DefaultServiceCodec = /** @class */ (function () {
    function DefaultServiceCodec() {
        this.debug = false;
        this.simple = false;
        this.utc = false;
        this.longType = 'number';
        this.dictType = 'object';
        this.nullType = undefined;
    }
    DefaultServiceCodec.prototype.encode = function (result, context) {
        var stream = new io_1.ByteStream();
        var writer = new io_1.Writer(stream, this.simple, this.utc);
        var headers = context.responseHeaders;
        if (this.simple) {
            headers.simple = true;
        }
        var size = 0;
        for (var _ in headers) {
            size++;
        }
        if (size > 0) {
            stream.writeByte(72 /* TagHeader */);
            writer.serialize(headers);
            writer.reset();
        }
        if (result instanceof Error) {
            stream.writeByte(69 /* TagError */);
            writer.serialize(this.debug ? result.stack ? result.stack : result.message : result.message);
        }
        else {
            stream.writeByte(82 /* TagResult */);
            writer.serialize(result);
        }
        stream.writeByte(122 /* TagEnd */);
        return stream.takeBytes();
    };
    DefaultServiceCodec.prototype.decodeMethod = function (name, context) {
        var service = context.service;
        var method = service.get(name);
        if (method === undefined) {
            throw new Error('Can\'t find this method ' + name + '().');
        }
        context.method = method;
        return method;
    };
    DefaultServiceCodec.prototype.decodeArguments = function (method, reader, context) {
        var stream = reader.stream;
        var tag = stream.readByte();
        if (method.missing) {
            if (tag === 97 /* TagList */) {
                reader.reset();
                return reader.read(tag, Array);
            }
            return [];
        }
        var args = [];
        if (tag === 97 /* TagList */) {
            reader.reset();
            var count = io_1.ValueReader.readCount(stream);
            var paramTypes = method.paramTypes;
            if (paramTypes === undefined) {
                paramTypes = new Array(count).fill(this.nullType);
            }
            else {
                paramTypes.length = count;
                for (var i = 0; i < count; ++i) {
                    if (paramTypes[i] === undefined) {
                        paramTypes[i] = this.nullType;
                    }
                }
            }
            args = new Array(count);
            reader.addReference(args);
            for (var i = 0; i < count; ++i) {
                args[i] = reader.deserialize(paramTypes[i]);
            }
            stream.readByte();
        }
        return args;
    };
    DefaultServiceCodec.prototype.decode = function (request, context) {
        if (request.length === 0) {
            this.decodeMethod('~', context);
            return ['~', []];
        }
        var stream = new io_1.ByteStream(request);
        var reader = new io_1.Reader(stream, false);
        reader.longType = this.longType;
        reader.dictType = this.dictType;
        var tag = stream.readByte();
        if (tag === 72 /* TagHeader */) {
            var headers = reader.deserialize(this.nullType);
            for (var name_1 in headers) {
                context.requestHeaders[name_1] = headers[name_1];
            }
            reader.reset();
            tag = stream.readByte();
        }
        switch (tag) {
            case 67 /* TagCall */:
                if (context.requestHeaders.simple) {
                    reader.simple = true;
                }
                var name_2 = reader.deserialize(String);
                var args = this.decodeArguments(this.decodeMethod(name_2, context), reader, context);
                return [name_2, args];
            case 122 /* TagEnd */:
                this.decodeMethod('~', context);
                return ['~', []];
            default:
                throw new Error('Invalid request:\r\n' + stream.toString());
        }
    };
    DefaultServiceCodec.instance = new DefaultServiceCodec();
    return DefaultServiceCodec;
}());
exports.DefaultServiceCodec = DefaultServiceCodec;
//# sourceMappingURL=ServiceCodec.js.map