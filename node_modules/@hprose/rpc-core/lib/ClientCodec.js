"use strict";
/*--------------------------------------------------------*\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: https://hprose.com                     |
|                                                          |
| ClientCodec.ts                                           |
|                                                          |
| ClientCodec for TypeScript.                              |
|                                                          |
| LastModified: Jan 27, 2019                               |
| Author: Ma Bingyao <andot@hprose.com>                    |
|                                                          |
\*________________________________________________________*/
Object.defineProperty(exports, "__esModule", { value: true });
var io_1 = require("@hprose/io");
var DefaultClientCodec = /** @class */ (function () {
    function DefaultClientCodec() {
        this.simple = false;
        this.utc = false;
        this.longType = 'number';
        this.dictType = 'object';
    }
    DefaultClientCodec.prototype.encode = function (name, args, context) {
        var stream = new io_1.ByteStream();
        var writer = new io_1.Writer(stream, this.simple, this.utc);
        var headers = context.requestHeaders;
        if (this.simple) {
            headers.simple = true;
        }
        var size = 0;
        for (var _ in headers) {
            size++;
        }
        if (size > 0) {
            stream.writeByte(72 /* TagHeader */);
            writer.serialize(headers);
            writer.reset();
        }
        stream.writeByte(67 /* TagCall */);
        writer.serialize(name);
        if (args.length > 0) {
            writer.reset();
            writer.serialize(args);
        }
        stream.writeByte(122 /* TagEnd */);
        return stream.takeBytes();
    };
    DefaultClientCodec.prototype.decode = function (response, context) {
        var stream = new io_1.ByteStream(response);
        var reader = new io_1.Reader(stream, false);
        reader.longType = this.longType;
        reader.dictType = this.dictType;
        var tag = stream.readByte();
        if (tag === 72 /* TagHeader */) {
            var headers = reader.deserialize();
            for (var name_1 in headers) {
                context.responseHeaders[name_1] = headers[name_1];
            }
            reader.reset();
            tag = stream.readByte();
        }
        switch (tag) {
            case 82 /* TagResult */:
                if (context.responseHeaders.simple) {
                    reader.simple = true;
                }
                return reader.deserialize(context.returnType);
            case 69 /* TagError */:
                throw new Error(reader.deserialize(String));
            case 122 /* TagEnd */:
                return context.type === null ? null : undefined;
            default:
                throw new Error('Invalid response:\r\n' + stream.toString());
        }
    };
    DefaultClientCodec.instance = new DefaultClientCodec();
    return DefaultClientCodec;
}());
exports.DefaultClientCodec = DefaultClientCodec;
//# sourceMappingURL=ClientCodec.js.map