import { ClientCodec } from './ClientCodec';
import { Context } from './Context';
import { ClientContext } from './ClientContext';
import { InvokeHandler } from './InvokeManager';
import { IOHandler } from './IOManager';
export interface Transport {
    transport(request: Uint8Array, context: Context): Promise<Uint8Array>;
    abort(): Promise<void>;
}
export interface TransportConstructor {
    readonly schemes: string[];
    new (): Transport;
}
export interface Client {
    [name: string]: any;
}
export declare class Client {
    private static transports;
    private static protocols;
    static register(name: string, ctor: TransportConstructor): void;
    readonly returnTypes: {
        [name: string]: Function | null;
    };
    readonly requestHeaders: {
        [name: string]: any;
    };
    codec: ClientCodec;
    timeout: number;
    private urilist;
    private readonly transports;
    private readonly invokeManager;
    private readonly ioManager;
    constructor(uri?: string | string[]);
    get uris(): string[];
    set uris(value: string[]);
    useService<T extends object>(returnTypes?: {
        [name in keyof T]: Function | null;
    }): T;
    useService<T extends object>(namespace: string, returnTypes?: {
        [name in keyof T]: Function | null;
    }): T;
    useService(names: string[]): any;
    useServiceAsync(): Promise<any>;
    use(...handlers: InvokeHandler[] | IOHandler[]): this;
    unuse(...handlers: InvokeHandler[] | IOHandler[]): this;
    invoke(name: string, args?: any[], context?: ClientContext | {
        [name: string]: any;
    }): Promise<any>;
    call(name: string, args: any[], context: Context): Promise<any>;
    request(request: Uint8Array, context: Context): Promise<Uint8Array>;
    transport(request: Uint8Array, context: Context): Promise<Uint8Array>;
    abort(): Promise<void>;
}
//# sourceMappingURL=Client.d.ts.map